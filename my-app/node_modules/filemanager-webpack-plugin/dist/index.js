import path from "path";
import { validate } from "schema-utils";
import normalizePath from "normalize-path";
import fs from "fs";
import fsExtra from "fs-extra";
import isGlob from "is-glob";
import fg from "fast-glob";
import { deleteAsync } from "del";
import archiver from "archiver";

//#region src/options-schema.ts
const optionsSchema = {
	title: "FileManagerPluginOptions",
	type: "object",
	additionalProperties: false,
	definitions: {
		Copy: {
			description: "Copy individual files or entire directories from a source folder to a destination folder",
			type: "array",
			minItems: 1,
			additionalItems: true,
			items: [{
				type: "object",
				additionalProperties: false,
				properties: {
					source: {
						description: "Copy source. A file or directory or a glob",
						type: "string",
						minLength: 1
					},
					destination: {
						description: "Copy destination",
						type: "string",
						minLength: 1
					},
					options: {
						additionalProperties: false,
						type: "object",
						description: "Options to forward to archiver",
						properties: {
							flat: {
								description: "Flatten the directory structure. All copied files will be put in the same directory",
								type: "boolean",
								default: false
							},
							overwrite: {
								description: "overwrite existing file or directory",
								type: "boolean",
								default: true
							},
							preserveTimestamps: {
								description: "Set last modification and access times to the ones of the original source files",
								type: "boolean",
								default: false
							}
						}
					},
					globOptions: {
						additionalProperties: true,
						type: "object",
						description: "Options to forward to fast-glob"
					}
				}
			}]
		},
		Delete: {
			description: "Delete individual files or entire directories",
			type: "array",
			minItems: 1,
			additionalItems: true,
			items: { anyOf: [{
				type: "object",
				additionalProperties: false,
				properties: {
					source: {
						type: "string",
						minLength: 1
					},
					options: {
						additionalProperties: true,
						type: "object",
						description: "Options to forward to del"
					}
				}
			}, {
				type: "string",
				minLength: 1
			}] }
		},
		Move: {
			description: "Move individual files or entire directories from a source folder to a destination folder",
			type: "array",
			additionalItems: true,
			items: [{
				type: "object",
				additionalProperties: false,
				properties: {
					source: {
						description: "Move source. A file or directory or a glob",
						type: "string",
						minLength: 1
					},
					destination: {
						description: "Move destination",
						type: "string",
						minLength: 1
					}
				}
			}]
		},
		Mkdir: {
			description: "Create Directories",
			type: "array",
			minItems: 1,
			additionalItems: true,
			items: { type: "string" }
		},
		Archive: {
			description: "Archive individual files or entire directories.",
			type: "array",
			additionalItems: true,
			items: [{
				type: "object",
				additionalProperties: false,
				properties: {
					source: {
						description: "Source. A file or directory or a glob",
						type: "string",
						minLength: 1
					},
					destination: {
						description: "Archive destination",
						type: "string",
						minLength: 1
					},
					format: {
						type: "string",
						enum: ["zip", "tar"]
					},
					options: {
						additionalProperties: true,
						type: "object",
						description: "Options to forward to archiver"
					}
				}
			}]
		},
		Actions: {
			type: "object",
			additionalProperties: false,
			properties: {
				copy: { $ref: "#/definitions/Copy" },
				delete: { $ref: "#/definitions/Delete" },
				move: { $ref: "#/definitions/Move" },
				mkdir: { $ref: "#/definitions/Mkdir" },
				archive: { $ref: "#/definitions/Archive" }
			}
		}
	},
	properties: {
		events: {
			type: "object",
			additionalProperties: false,
			properties: {
				onStart: { oneOf: [{ $ref: "#/definitions/Actions" }, {
					type: "array",
					items: { $ref: "#/definitions/Actions" }
				}] },
				onEnd: { oneOf: [{ $ref: "#/definitions/Actions" }, {
					type: "array",
					items: { $ref: "#/definitions/Actions" }
				}] }
			}
		},
		runTasksInSeries: {
			type: "boolean",
			default: false,
			description: "Run tasks in an action in series"
		},
		context: {
			type: "string",
			description: "The directory, an absolute path, for resolving files. Defaults to webpack context"
		},
		throwOnError: {
			type: "boolean",
			default: false,
			description: "If true, will throw an error if any action fails"
		},
		runOnceInWatchMode: {
			type: "boolean",
			default: false,
			description: "Run tasks only at first compilation in watch mode"
		}
	}
};
var options_schema_default = optionsSchema;

//#endregion
//#region src/utils/p-exec.ts
const defaultTask = async () => {};
const pExec = async (series = false, arr = [], task = defaultTask) => {
	if (series) {
		await arr.reduce(async (p, spec) => {
			await p;
			return task(spec);
		}, Promise.resolve(null));
		return;
	}
	const pMap = arr.map(task);
	await Promise.all(pMap);
};
var p_exec_default = pExec;

//#endregion
//#region src/utils/glob-copy.ts
const defaultOptions$1 = {
	flat: false,
	cwd: process.cwd()
};
const destPath = (pattern, file, options = defaultOptions$1) => {
	if (options.flat) return path.posix.basename(file);
	const pathArr = pattern.split("/");
	const globIndex = pathArr.findIndex((item) => item ? fg.isDynamicPattern(item) : false);
	const normalized = pathArr.slice(0, globIndex).join("/");
	const absolutePath = path.isAbsolute(normalized) ? normalized : path.posix.join(options.cwd, normalized);
	return path.relative(absolutePath, file);
};
const globCopy = async (pattern, destination, options = defaultOptions$1, globOptions = {}) => {
	const mergedOptions = {
		...defaultOptions$1,
		...options
	};
	await fsExtra.ensureDir(destination);
	const matches = await fg(pattern, {
		dot: true,
		...globOptions,
		absolute: true,
		cwd: mergedOptions.cwd
	});
	const entries = matches.map((file) => {
		const destDir = path.isAbsolute(destination) ? destination : path.posix.join(mergedOptions.cwd, destination);
		const destFileName = destPath(pattern, file, mergedOptions);
		return {
			from: file,
			destDir,
			destFileName,
			to: path.posix.join(destDir, destFileName)
		};
	});
	const cpPromises = entries.map(async (entry) => {
		const copyOptions = {
			overwrite: mergedOptions.overwrite,
			preserveTimestamps: mergedOptions.preserveTimestamps
		};
		return fsExtra.copy(entry.from, entry.to, copyOptions);
	});
	return Promise.all(cpPromises);
};
var glob_copy_default = globCopy;

//#endregion
//#region src/actions/copy.ts
const fsExtraDefaultOptions = { preserveTimestamps: true };
const copy = async (task, { logger }) => {
	const { source, absoluteSource, destination, absoluteDestination, context = process.cwd(), toType, options = {}, globOptions = {} } = task;
	logger.log(`copying from ${source} to ${destination}`);
	if (isGlob(source)) {
		const cpOptions = {
			...options,
			cwd: context
		};
		await glob_copy_default(source, absoluteDestination, cpOptions, globOptions);
	} else {
		const isSourceFile = fs.lstatSync(absoluteSource).isFile();
		if (isSourceFile && toType === "dir") {
			await fsExtra.ensureDir(absoluteDestination);
			const sourceFileName = path.posix.basename(absoluteSource);
			const filePath = path.resolve(absoluteDestination, sourceFileName);
			await fsExtra.copy(absoluteSource, filePath, fsExtraDefaultOptions);
			return;
		}
		await fsExtra.copy(absoluteSource, absoluteDestination, fsExtraDefaultOptions);
	}
	logger.info(`copied "${source}" to "${destination}"`);
};
const copyAction = async (tasks, taskOptions) => {
	const { runTasksInSeries, logger, handleError } = taskOptions;
	logger.debug(`processing copy tasks. tasks: ${tasks}`);
	await p_exec_default(runTasksInSeries, tasks, async (task) => {
		try {
			await copy(task, taskOptions);
		} catch (err) {
			logger.error(`error while copying. task ${err}`);
			handleError(err);
		}
	});
	logger.debug(`copy tasks complete. tasks: ${tasks}`);
};
var copy_default = copyAction;

//#endregion
//#region src/actions/delete.ts
const deleteAction = async (tasks, taskOptions) => {
	const { runTasksInSeries, logger, handleError } = taskOptions;
	logger.debug(`processing delete tasks. tasks: ${tasks}`);
	await p_exec_default(runTasksInSeries, tasks, async (task) => {
		const { options = {} } = task;
		try {
			await deleteAsync(task.absoluteSource, options);
			logger.info(`deleted ${task.source}`);
		} catch (err) {
			logger.error(`unable to delete ${task.source}. ${err}`);
			handleError(err);
		}
	});
	logger.debug(`delete tasks complete. tasks: ${tasks}`);
};
var delete_default = deleteAction;

//#endregion
//#region src/actions/move.ts
const moveAction = async (tasks, taskOptions) => {
	const { runTasksInSeries, logger, handleError } = taskOptions;
	logger.debug(`processing move tasks. tasks: ${tasks}`);
	await p_exec_default(runTasksInSeries, tasks, async (task) => {
		try {
			await fsExtra.move(task.absoluteSource, task.absoluteDestination);
			logger.info(`moved ${task.source} to ${task.destination}`);
		} catch (err) {
			logger.error(`unable to move ${task.source}, ${err}`);
			handleError(err);
		}
	});
	logger.debug(`move tasks complete. tasks: ${tasks}`);
};
var move_default = moveAction;

//#endregion
//#region src/actions/mkdir.ts
const mkdirAction = async (tasks, taskOptions) => {
	const { runTasksInSeries, logger, handleError } = taskOptions;
	logger.debug(`processing mkdir tasks. tasks: ${tasks}`);
	await p_exec_default(runTasksInSeries, tasks, async (task) => {
		try {
			await fs.promises.mkdir(task.absoluteSource, { recursive: true });
			logger.info(`created directory. ${task.source}`);
		} catch (err) {
			logger.error(`unable to create directory: ${task.source}. ${err}`);
			handleError(err);
		}
	});
	logger.debug(`mkdir tasks complete. tasks: ${tasks}`);
};
var mkdir_default = mkdirAction;

//#endregion
//#region src/actions/archive.ts
const archive = async (task, { logger }) => {
	const { source, absoluteSource, absoluteDestination, options = {}, context = process.cwd() } = task;
	const format = task.format || path.extname(absoluteDestination).replace(".", "");
	const destFile = path.basename(absoluteDestination);
	const destDir = path.dirname(absoluteDestination);
	const { globOptions = {},...archiverOptions } = options;
	const ignore = Array.isArray(globOptions.ignore) ? [...globOptions.ignore, destFile] : [destFile];
	const fileToIgnore = typeof globOptions.ignore === "string" ? [...ignore, globOptions.ignore] : ignore;
	const finalGlobOptions = {
		...globOptions,
		ignore: fileToIgnore
	};
	await fsExtra.ensureDir(destDir);
	const output = fs.createWriteStream(absoluteDestination);
	const arch = archiver(format, archiverOptions);
	const streamClose = () => new Promise((resolve) => output.on("close", () => resolve()));
	arch.pipe(output);
	logger.log(`archiving src ${source}`);
	if (isGlob(source)) {
		const opts = {
			...finalGlobOptions,
			cwd: context
		};
		await arch.glob(source, opts).finalize();
	} else {
		const sStat = fs.lstatSync(absoluteSource);
		if (sStat.isDirectory()) {
			const opts = {
				...finalGlobOptions,
				cwd: absoluteSource
			};
			await arch.glob("**/*", opts).finalize();
		}
		if (sStat.isFile()) {
			const opts = { name: path.basename(source) };
			await arch.file(absoluteSource, opts).finalize();
		}
	}
	await streamClose();
	logger.info(`archive created at "${absoluteDestination}"`);
};
const archiveAction = async (tasks, taskOptions) => {
	const { runTasksInSeries, logger, handleError } = taskOptions;
	logger.debug(`processing archive tasks. tasks: ${tasks}`);
	await p_exec_default(runTasksInSeries, tasks, async (task) => {
		try {
			await archive(task, taskOptions);
		} catch (err) {
			logger.error(`error while creating archive. task ${task}`);
			handleError(err);
		}
	});
	logger.debug(`archive tasks complete. tasks: ${tasks}`);
};
var archive_default = archiveAction;

//#endregion
//#region src/index.ts
const PLUGIN_NAME = "FileManagerPlugin";
const defaultOptions = {
	events: {
		onStart: [],
		onEnd: []
	},
	runTasksInSeries: false,
	context: null,
	runOnceInWatchMode: false,
	throwOnError: false
};
function resolvePaths(action, context) {
	return action.map((task) => {
		if (typeof task === "string") {
			const source$1 = task;
			return {
				source: source$1,
				absoluteSource: path.isAbsolute(source$1) ? source$1 : path.join(context, source$1)
			};
		}
		const { source } = task;
		if ("options" in task && !("destination" in task)) return {
			...task,
			source,
			absoluteSource: path.isAbsolute(source) ? source : path.join(context, source)
		};
		const destination = "destination" in task ? task.destination : void 0;
		if (!destination) return {
			...task,
			source,
			absoluteSource: path.isAbsolute(source) ? source : path.join(context, source)
		};
		const toType = /(?:\\|\/)$/.test(destination) ? "dir" : "file";
		const absoluteSource = path.isAbsolute(source) ? source : path.join(context, source);
		const absoluteDestination = path.isAbsolute(destination) ? destination : path.join(context, destination);
		return {
			...task,
			source: normalizePath(source),
			absoluteSource: normalizePath(absoluteSource),
			destination: normalizePath(destination),
			absoluteDestination: normalizePath(absoluteDestination),
			toType,
			context
		};
	});
}
var FileManagerPlugin = class {
	options;
	context;
	logger;
	constructor(options) {
		validate(options_schema_default, options, {
			name: PLUGIN_NAME,
			baseDataPath: "actions"
		});
		this.options = {
			...defaultOptions,
			...options
		};
	}
	async applyAction(action, actionParams, compilation) {
		const opts = {
			runTasksInSeries: this.options.runTasksInSeries ?? false,
			logger: this.logger,
			handleError: (error) => {
				if (!this.options.throwOnError) return;
				compilation.errors.push(error);
			}
		};
		if (typeof action === "function") await action(resolvePaths(actionParams, this.context), opts);
	}
	async run(event, compilation) {
		for (const actionType in event) {
			const action = event[actionType];
			switch (actionType) {
				case "delete":
					await this.applyAction(delete_default, action, compilation);
					break;
				case "mkdir":
					await this.applyAction(mkdir_default, action, compilation);
					break;
				case "copy":
					await this.applyAction(copy_default, action, compilation);
					break;
				case "move":
					await this.applyAction(move_default, action, compilation);
					break;
				case "archive":
					await this.applyAction(archive_default, action, compilation);
					break;
				default: compilation.errors.push(/* @__PURE__ */ new Error("Unknown action"));
			}
		}
	}
	async execute(eventName, compilation) {
		const { events } = this.options;
		if (!events) return;
		if (Array.isArray(events[eventName])) {
			const eventsArr = events[eventName];
			await p_exec_default(true, eventsArr, async (event$1) => await this.run(event$1, compilation));
			return;
		}
		const event = events[eventName];
		await this.run(event, compilation);
	}
	apply(compiler) {
		this.context = this.options.context || compiler.options.context || process.cwd();
		this.logger = compiler.getInfrastructureLogger(PLUGIN_NAME);
		const onStart = async (compilation) => {
			await this.execute("onStart", compilation);
		};
		const onEnd = async (compilation) => {
			await this.execute("onEnd", compilation);
		};
		compiler.hooks.beforeRun.tapPromise(PLUGIN_NAME, async (comp) => {
			comp.hooks.thisCompilation.tap(PLUGIN_NAME, async (compilation) => {
				await onStart(compilation);
			});
		});
		compiler.hooks.afterEmit.tapPromise(PLUGIN_NAME, async (compilation) => {
			await onEnd(compilation);
		});
		let watchRunCount = 0;
		compiler.hooks.watchRun.tapPromise(PLUGIN_NAME, async (comp) => {
			if (this.options.runOnceInWatchMode && watchRunCount > 0) return;
			++watchRunCount;
			comp.hooks.thisCompilation.tap(PLUGIN_NAME, async (compilation) => {
				await onStart(compilation);
			});
		});
	}
};
var src_default = FileManagerPlugin;

//#endregion
export { src_default as default };
//# sourceMappingURL=index.js.map