{"version":3,"file":"index.js","names":["optionsSchema: JSONSchema7","series: boolean","arr: T[]","task: (item: T) => Promise<void>","defaultOptions: GlobCopyOptions","pattern: string","file: string","options: GlobCopyOptions","defaultOptions","destination: string","globOptions: Record<string, any>","task: CopyTask","tasks: CopyTask[]","taskOptions: TaskOptions","tasks: DeleteTask[]","taskOptions: TaskOptions","task: DeleteTask","tasks: MoveTask[]","taskOptions: TaskOptions","task: MoveTask","tasks: MkdirTask[]","taskOptions: TaskOptions","task: MkdirTask","task: ArchiveTask","tasks: ArchiveTask[]","taskOptions: TaskOptions","defaultOptions: FileManagerPluginOptions","action: ActionTask[]","context: string","source","options: FileManagerPluginOptions","optionsSchema","action: unknown","actionParams: ActionTask[]","compilation: Compilation","opts: TaskOptions","event: Actions","deleteAction","mkdirAction","copyAction","moveAction","archiveAction","eventName: 'onStart' | 'onEnd'","event","compiler: Compiler"],"sources":["../src/options-schema.ts","../src/utils/p-exec.ts","../src/utils/glob-copy.ts","../src/actions/copy.ts","../src/actions/delete.ts","../src/actions/move.ts","../src/actions/mkdir.ts","../src/actions/archive.ts","../src/index.ts"],"sourcesContent":["import type { JSONSchema7 } from 'schema-utils';\n\nconst optionsSchema: JSONSchema7 = {\n  title: 'FileManagerPluginOptions',\n  type: 'object',\n  additionalProperties: false,\n  definitions: {\n    Copy: {\n      description: 'Copy individual files or entire directories from a source folder to a destination folder',\n      type: 'array',\n      minItems: 1,\n      additionalItems: true,\n      items: [\n        {\n          type: 'object',\n          additionalProperties: false,\n          properties: {\n            source: {\n              description: 'Copy source. A file or directory or a glob',\n              type: 'string',\n              minLength: 1,\n            },\n            destination: {\n              description: 'Copy destination',\n              type: 'string',\n              minLength: 1,\n            },\n            options: {\n              additionalProperties: false,\n              type: 'object',\n              description: 'Options to forward to archiver',\n              properties: {\n                flat: {\n                  description: 'Flatten the directory structure. All copied files will be put in the same directory',\n                  type: 'boolean',\n                  default: false,\n                },\n                overwrite: {\n                  description: 'overwrite existing file or directory',\n                  type: 'boolean',\n                  default: true,\n                },\n                preserveTimestamps: {\n                  description: 'Set last modification and access times to the ones of the original source files',\n                  type: 'boolean',\n                  default: false,\n                },\n              },\n            },\n            globOptions: {\n              additionalProperties: true,\n              type: 'object',\n              description: 'Options to forward to fast-glob',\n            },\n          },\n        },\n      ],\n    },\n    Delete: {\n      description: 'Delete individual files or entire directories',\n      type: 'array',\n      minItems: 1,\n      additionalItems: true,\n      items: {\n        anyOf: [\n          {\n            type: 'object',\n            additionalProperties: false,\n            properties: {\n              source: {\n                type: 'string',\n                minLength: 1,\n              },\n              options: {\n                additionalProperties: true,\n                type: 'object',\n                description: 'Options to forward to del',\n              },\n            },\n          },\n          {\n            type: 'string',\n            minLength: 1,\n          },\n        ],\n      },\n    },\n    Move: {\n      description: 'Move individual files or entire directories from a source folder to a destination folder',\n      type: 'array',\n      additionalItems: true,\n      items: [\n        {\n          type: 'object',\n          additionalProperties: false,\n          properties: {\n            source: {\n              description: 'Move source. A file or directory or a glob',\n              type: 'string',\n              minLength: 1,\n            },\n            destination: {\n              description: 'Move destination',\n              type: 'string',\n              minLength: 1,\n            },\n          },\n        },\n      ],\n    },\n    Mkdir: {\n      description: 'Create Directories',\n      type: 'array',\n      minItems: 1,\n      additionalItems: true,\n      items: {\n        type: 'string',\n      },\n    },\n    Archive: {\n      description: 'Archive individual files or entire directories.',\n      type: 'array',\n      additionalItems: true,\n      items: [\n        {\n          type: 'object',\n          additionalProperties: false,\n          properties: {\n            source: {\n              description: 'Source. A file or directory or a glob',\n              type: 'string',\n              minLength: 1,\n            },\n            destination: {\n              description: 'Archive destination',\n              type: 'string',\n              minLength: 1,\n            },\n            format: {\n              type: 'string',\n              enum: ['zip', 'tar'],\n            },\n            options: {\n              additionalProperties: true,\n              type: 'object',\n              description: 'Options to forward to archiver',\n            },\n          },\n        },\n      ],\n    },\n    Actions: {\n      type: 'object',\n      additionalProperties: false,\n      properties: {\n        copy: {\n          $ref: '#/definitions/Copy',\n        },\n        delete: {\n          $ref: '#/definitions/Delete',\n        },\n        move: {\n          $ref: '#/definitions/Move',\n        },\n        mkdir: {\n          $ref: '#/definitions/Mkdir',\n        },\n        archive: {\n          $ref: '#/definitions/Archive',\n        },\n      },\n    },\n  },\n  properties: {\n    events: {\n      type: 'object',\n      additionalProperties: false,\n      properties: {\n        onStart: {\n          oneOf: [\n            {\n              $ref: '#/definitions/Actions',\n            },\n            {\n              type: 'array',\n              items: {\n                $ref: '#/definitions/Actions',\n              },\n            },\n          ],\n        },\n        onEnd: {\n          oneOf: [\n            {\n              $ref: '#/definitions/Actions',\n            },\n            {\n              type: 'array',\n              items: {\n                $ref: '#/definitions/Actions',\n              },\n            },\n          ],\n        },\n      },\n    },\n    runTasksInSeries: {\n      type: 'boolean',\n      default: false,\n      description: 'Run tasks in an action in series',\n    },\n    context: {\n      type: 'string',\n      description: 'The directory, an absolute path, for resolving files. Defaults to webpack context',\n    },\n    throwOnError: {\n      type: 'boolean',\n      default: false,\n      description: 'If true, will throw an error if any action fails',\n    },\n    runOnceInWatchMode: {\n      type: 'boolean',\n      default: false,\n      description: 'Run tasks only at first compilation in watch mode',\n    },\n  },\n};\n\nexport default optionsSchema;\n","const defaultTask = async (): Promise<void> => {};\n\nconst pExec = async <T>(\n  series: boolean = false,\n  arr: T[] = [],\n  task: (item: T) => Promise<void> = defaultTask\n): Promise<void> => {\n  if (series) {\n    await arr.reduce(async (p, spec) => {\n      await p;\n      return task(spec);\n    }, Promise.resolve(null));\n    return;\n  }\n\n  const pMap = arr.map(task);\n  await Promise.all(pMap);\n};\n\nexport default pExec;\n","import path from 'path';\nimport fse, { CopyOptions } from 'fs-extra';\nimport fg from 'fast-glob';\n\ntype FsCopyOptions = Pick<CopyOptions, 'overwrite' | 'preserveTimestamps'>;\ninterface GlobCopyOptions extends FsCopyOptions {\n  flat?: boolean;\n  cwd?: string;\n}\n\nconst defaultOptions: GlobCopyOptions = {\n  flat: false,\n  cwd: process.cwd(),\n};\n\nconst destPath = (pattern: string, file: string, options: GlobCopyOptions = defaultOptions): string => {\n  if (options.flat) {\n    return path.posix.basename(file);\n  }\n\n  const pathArr = pattern.split('/');\n  const globIndex = pathArr.findIndex((item) => (item ? fg.isDynamicPattern(item) : false));\n  const normalized = pathArr.slice(0, globIndex).join('/');\n\n  const absolutePath = path.isAbsolute(normalized) ? normalized : path.posix.join(options.cwd, normalized);\n\n  return path.relative(absolutePath, file);\n};\n\nconst globCopy = async (\n  pattern: string,\n  destination: string,\n  options: GlobCopyOptions = defaultOptions,\n  globOptions: Record<string, any> = {}\n): Promise<void[]> => {\n  const mergedOptions = { ...defaultOptions, ...options };\n\n  await fse.ensureDir(destination);\n\n  const matches = await fg(pattern, { dot: true, ...globOptions, absolute: true, cwd: mergedOptions.cwd });\n\n  const entries = matches.map((file) => {\n    const destDir = path.isAbsolute(destination) ? destination : path.posix.join(mergedOptions.cwd, destination);\n    const destFileName = destPath(pattern, file, mergedOptions);\n\n    return {\n      from: file,\n      destDir,\n      destFileName,\n      to: path.posix.join(destDir, destFileName),\n    };\n  });\n\n  const cpPromises = entries.map(async (entry) => {\n    const copyOptions = {\n      overwrite: mergedOptions.overwrite,\n      preserveTimestamps: mergedOptions.preserveTimestamps,\n    };\n\n    return fse.copy(entry.from, entry.to, copyOptions);\n  });\n\n  return Promise.all(cpPromises);\n};\n\nexport default globCopy;\n","import fs from 'fs';\nimport path from 'path';\nimport fsExtra from 'fs-extra';\nimport isGlob from 'is-glob';\nimport type { Options as FgOptions } from 'fast-glob';\nimport type { CopyOptions } from 'fs-extra';\n\nimport pExec from '../utils/p-exec';\nimport globCopy from '../utils/glob-copy';\nimport { TaskOptions } from '../types';\n\ntype FsCopyOptions = Pick<CopyOptions, 'overwrite' | 'preserveTimestamps'>;\n\n// Define internal types based on the exported types\nexport interface CopyActionOptions extends FsCopyOptions {\n  /**\n   * If true, the copy operation will not preserve the directory structure\n   * and will copy all files to the destination directory.\n   */\n  flat?: boolean;\n}\n\nexport type CopyGlobOptions = Omit<FgOptions, 'absolute' | 'cwd'>;\n\nexport interface CopyTask {\n  source: string;\n  absoluteSource: string;\n  destination: string;\n  absoluteDestination?: string;\n  context?: string;\n  toType?: 'dir' | 'file';\n  options?: CopyActionOptions;\n  globOptions?: CopyGlobOptions;\n}\n\nconst fsExtraDefaultOptions = {\n  preserveTimestamps: true,\n};\n\nconst copy = async (task: CopyTask, { logger }: TaskOptions): Promise<void> => {\n  const {\n    source,\n    absoluteSource,\n    destination,\n    absoluteDestination,\n    context = process.cwd(),\n    toType,\n    options = {},\n    globOptions = {},\n  } = task;\n\n  logger.log(`copying from ${source} to ${destination}`);\n\n  if (isGlob(source)) {\n    const cpOptions = {\n      ...options,\n      cwd: context,\n    };\n\n    await globCopy(source, absoluteDestination, cpOptions, globOptions);\n  } else {\n    const isSourceFile = fs.lstatSync(absoluteSource).isFile();\n\n    // if source is a file and target is a directory\n    // create the directory and copy the file into that directory\n    if (isSourceFile && toType === 'dir') {\n      await fsExtra.ensureDir(absoluteDestination);\n\n      const sourceFileName = path.posix.basename(absoluteSource);\n      const filePath = path.resolve(absoluteDestination, sourceFileName);\n\n      await fsExtra.copy(absoluteSource, filePath, fsExtraDefaultOptions);\n      return;\n    }\n\n    await fsExtra.copy(absoluteSource, absoluteDestination, fsExtraDefaultOptions);\n  }\n\n  logger.info(`copied \"${source}\" to \"${destination}\"`);\n};\n\nconst copyAction = async (tasks: CopyTask[], taskOptions: TaskOptions): Promise<void> => {\n  const { runTasksInSeries, logger, handleError } = taskOptions;\n\n  logger.debug(`processing copy tasks. tasks: ${tasks}`);\n\n  await pExec(runTasksInSeries, tasks, async (task: CopyTask) => {\n    try {\n      await copy(task, taskOptions);\n    } catch (err) {\n      logger.error(`error while copying. task ${err}`);\n      handleError(err);\n    }\n  });\n  logger.debug(`copy tasks complete. tasks: ${tasks}`);\n};\n\nexport default copyAction;\n","import { deleteAsync, Options as DelOptions } from 'del';\n\nimport pExec from '../utils/p-exec';\nimport { TaskOptions } from '../types';\n\nexport type { DelOptions as DeleteOptions };\n\nexport interface DeleteTask {\n  source: string;\n  absoluteSource: string;\n  options?: DelOptions;\n}\n\nconst deleteAction = async (tasks: DeleteTask[], taskOptions: TaskOptions): Promise<void> => {\n  const { runTasksInSeries, logger, handleError } = taskOptions;\n\n  logger.debug(`processing delete tasks. tasks: ${tasks}`);\n\n  await pExec(runTasksInSeries, tasks, async (task: DeleteTask) => {\n    const { options = {} } = task;\n\n    try {\n      await deleteAsync(task.absoluteSource, options);\n      logger.info(`deleted ${task.source}`);\n    } catch (err) {\n      logger.error(`unable to delete ${task.source}. ${err}`);\n      handleError(err);\n    }\n  });\n\n  logger.debug(`delete tasks complete. tasks: ${tasks}`);\n};\n\nexport default deleteAction;\n","import fsExtra from 'fs-extra';\n\nimport pExec from '../utils/p-exec';\nimport { TaskOptions } from '../types';\n\nexport interface MoveTask {\n  source: string;\n  absoluteSource: string;\n  destination: string;\n  absoluteDestination: string;\n}\n\nconst moveAction = async (tasks: MoveTask[], taskOptions: TaskOptions): Promise<void> => {\n  const { runTasksInSeries, logger, handleError } = taskOptions;\n\n  logger.debug(`processing move tasks. tasks: ${tasks}`);\n\n  await pExec(runTasksInSeries, tasks, async (task: MoveTask) => {\n    try {\n      await fsExtra.move(task.absoluteSource, task.absoluteDestination);\n      logger.info(`moved ${task.source} to ${task.destination}`);\n    } catch (err) {\n      logger.error(`unable to move ${task.source}, ${err}`);\n      handleError(err);\n    }\n  });\n\n  logger.debug(`move tasks complete. tasks: ${tasks}`);\n};\n\nexport default moveAction;\n","import fs from 'fs';\n\nimport pExec from '../utils/p-exec';\nimport { TaskOptions } from '../types';\n\nexport interface MkdirTask {\n  source: string;\n  absoluteSource: string;\n}\n\nconst mkdirAction = async (tasks: MkdirTask[], taskOptions: TaskOptions): Promise<void> => {\n  const { runTasksInSeries, logger, handleError } = taskOptions;\n\n  logger.debug(`processing mkdir tasks. tasks: ${tasks}`);\n\n  await pExec(runTasksInSeries, tasks, async (task: MkdirTask) => {\n    try {\n      await fs.promises.mkdir(task.absoluteSource, { recursive: true });\n      logger.info(`created directory. ${task.source}`);\n    } catch (err) {\n      logger.error(`unable to create directory: ${task.source}. ${err}`);\n      handleError(err);\n    }\n  });\n\n  logger.debug(`mkdir tasks complete. tasks: ${tasks}`);\n};\n\nexport default mkdirAction;\n","import fs from 'fs';\nimport path from 'path';\nimport archiver, { type ArchiverOptions as ArchiverJSOptions } from 'archiver';\nimport isGlob from 'is-glob';\nimport fsExtra from 'fs-extra';\n\nimport pExec from '../utils/p-exec';\nimport { TaskOptions } from '../types';\n\n/** {@link https://github.com/Yqnn/node-readdir-glob#options} */\ninterface ReaddirGlobOptions {\n  /** Glob pattern or Array of Glob patterns to match the found files with. A file has to match at least one of the provided patterns to be returned. */\n  pattern?: string | string[];\n  /** Glob pattern or Array of Glob patterns to exclude matches. If a file or a folder matches at least one of the provided patterns, it's not returned. It doesn't prevent files from folder content to be returned. Note: ignore patterns are always in dot:true mode. */\n  ignore?: string | string[];\n  /** Glob pattern or Array of Glob patterns to exclude folders. If a folder matches one of the provided patterns, it's not returned, and it's not explored: this prevents any of its children to be returned. Note: skip patterns are always in dot:true mode. */\n  skip?: string | string[];\n  /** Add a / character to directory matches. */\n  mark?: boolean;\n  /** Set to true to stat all results. This reduces performance. */\n  stat?: boolean;\n  /** When an unusual error is encountered when attempting to read a directory, a warning will be printed to stderr. Set the silent option to true to suppress these warnings. */\n  silent?: boolean;\n  /** Do not match directories, only files. */\n  nodir?: boolean;\n  /** Follow symlinked directories. Note that requires to stat all results, and so reduces performance. */\n  follow?: boolean;\n  /** Allow pattern to match filenames starting with a period, even if the pattern does not explicitly have a period in that spot. */\n  dot?: boolean;\n  /** Disable ** matching against multiple folder names. */\n  noglobstar?: boolean;\n  /** Perform a case-insensitive match. Note: on case-insensitive filesystems, non-magic patterns will match by default, since stat and readdir will not raise errors. */\n  nocase?: boolean;\n  /** Perform a basename-only match if the pattern does not contain any slash characters. That is, *.js would be treated as equivalent to ** /*.js, matching all js files in all directories. */\n  matchBase?: boolean;\n}\n\nexport type ArchiverOptions = ArchiverJSOptions & {\n  globOptions?: ReaddirGlobOptions;\n};\n\nexport interface ArchiveTask {\n  source: string;\n  absoluteSource: string;\n  absoluteDestination: string;\n  context?: string;\n  format?: 'zip' | 'tar';\n  options?: ArchiverOptions;\n}\n\nconst archive = async (task: ArchiveTask, { logger }: TaskOptions): Promise<void> => {\n  const { source, absoluteSource, absoluteDestination, options = {}, context = process.cwd() } = task;\n  const format = task.format || (path.extname(absoluteDestination).replace('.', '') as 'zip' | 'tar');\n\n  // Exclude destination file from archive\n  const destFile = path.basename(absoluteDestination);\n  const destDir = path.dirname(absoluteDestination);\n\n  const { globOptions = {}, ...archiverOptions } = options;\n\n  const ignore = Array.isArray(globOptions.ignore) ? [...globOptions.ignore, destFile] : [destFile];\n  const fileToIgnore = typeof globOptions.ignore === 'string' ? [...ignore, globOptions.ignore] : ignore;\n  const finalGlobOptions = { ...globOptions, ignore: fileToIgnore };\n\n  await fsExtra.ensureDir(destDir);\n\n  const output = fs.createWriteStream(absoluteDestination);\n  const arch = archiver(format, archiverOptions);\n\n  const streamClose = (): Promise<void> => new Promise((resolve) => output.on('close', () => resolve()));\n\n  arch.pipe(output);\n\n  logger.log(`archiving src ${source}`);\n\n  if (isGlob(source)) {\n    const opts = {\n      ...finalGlobOptions,\n      cwd: context,\n    };\n\n    await arch.glob(source, opts).finalize();\n  } else {\n    const sStat = fs.lstatSync(absoluteSource);\n\n    if (sStat.isDirectory()) {\n      const opts = {\n        ...finalGlobOptions,\n        cwd: absoluteSource,\n      };\n\n      await arch.glob('**/*', opts).finalize();\n    }\n\n    if (sStat.isFile()) {\n      const opts = {\n        name: path.basename(source),\n      };\n\n      await arch.file(absoluteSource, opts).finalize();\n    }\n  }\n\n  await streamClose();\n\n  logger.info(`archive created at \"${absoluteDestination}\"`);\n};\n\nconst archiveAction = async (tasks: ArchiveTask[], taskOptions: TaskOptions): Promise<void> => {\n  const { runTasksInSeries, logger, handleError } = taskOptions;\n\n  logger.debug(`processing archive tasks. tasks: ${tasks}`);\n  await pExec(runTasksInSeries, tasks, async (task: ArchiveTask) => {\n    try {\n      await archive(task, taskOptions);\n    } catch (err) {\n      logger.error(`error while creating archive. task ${task}`);\n      handleError(err);\n    }\n  });\n  logger.debug(`archive tasks complete. tasks: ${tasks}`);\n};\n\nexport default archiveAction;\n","import path from 'path';\nimport { validate } from 'schema-utils';\nimport normalizePath from 'normalize-path';\nimport type { Compilation, Compiler, WebpackPluginInstance } from 'webpack';\n\nimport optionsSchema from './options-schema';\nimport pExec from './utils/p-exec';\nimport copyAction, { CopyActionOptions, CopyGlobOptions, CopyTask } from './actions/copy';\nimport deleteAction, { DeleteTask, DeleteOptions } from './actions/delete';\nimport moveAction, { MoveTask } from './actions/move';\nimport mkdirAction, { MkdirTask } from './actions/mkdir';\nimport archiveAction, { ArchiveTask, ArchiverOptions } from './actions/archive';\nimport { TaskOptions, Logger } from './types';\n\ntype CopyAction = {\n  source: string;\n  destination: string;\n  options?: CopyActionOptions;\n  globOptions?: CopyGlobOptions;\n};\n\ntype DeleteAction =\n  | {\n      source: string;\n      options: DeleteOptions;\n    }\n  | string;\n\ntype MoveAction = {\n  source: string;\n  destination: string;\n};\n\ntype ArchiveAction = {\n  source: string;\n  destination: string;\n  format?: 'zip' | 'tar';\n  options?: ArchiverOptions;\n};\n\ntype MkdirAction = string;\n\ninterface Actions {\n  copy?: CopyAction[];\n  delete?: DeleteAction[];\n  move?: MoveAction[];\n  mkdir?: MkdirAction[];\n  archive?: ArchiveAction[];\n}\n\nexport interface FileManagerPluginOptions {\n  events?: {\n    /**\n     * Commands to execute before Webpack begins the bundling process\n     * Note: OnStart might execute twice for file changes in webpack context.\n     */\n    onStart?: Actions | Actions[];\n    /**\n     * Commands to execute after Webpack has finished the bundling process\n     */\n    onEnd?: Actions | Actions[];\n  };\n  /**\n   * Run tasks in an action in series\n   */\n  runTasksInSeries?: boolean;\n  /**\n   * Run tasks only at first compilation in watch mode\n   */\n  runOnceInWatchMode?: boolean;\n  /**\n   * The directory, an absolute path, for resolving files. Defaults to webpack context\n   */\n  context?: string | null;\n  /**\n   * If true, will throw an error if any action fails\n   * @default false\n   */\n  throwOnError?: boolean;\n}\n\ntype ActionTask = string | CopyAction | DeleteAction | MoveAction | ArchiveAction;\ntype ResolvedActionTask = CopyTask | MoveTask | DeleteTask | MkdirTask | ArchiveTask;\n\nconst PLUGIN_NAME = 'FileManagerPlugin';\n\nconst defaultOptions: FileManagerPluginOptions = {\n  events: {\n    onStart: [],\n    onEnd: [],\n  },\n  runTasksInSeries: false,\n  context: null,\n  runOnceInWatchMode: false,\n  throwOnError: false,\n};\n\nfunction resolvePaths(action: ActionTask[], context: string): ResolvedActionTask[] {\n  return action.map((task) => {\n    if (typeof task === 'string') {\n      const source = task;\n      return {\n        source,\n        absoluteSource: path.isAbsolute(source) ? source : path.join(context, source),\n      };\n    }\n\n    const { source } = task;\n\n    // Handle delete actions that might not have a destination\n    if ('options' in task && !('destination' in task)) {\n      return {\n        ...task,\n        source,\n        absoluteSource: path.isAbsolute(source) ? source : path.join(context, source),\n      };\n    }\n\n    // Handle actions with destinations (copy, move, archive)\n    const destination = 'destination' in task ? task.destination : undefined;\n\n    if (!destination) {\n      return {\n        ...task,\n        source,\n        absoluteSource: path.isAbsolute(source) ? source : path.join(context, source),\n      };\n    }\n\n    const toType = /(?:\\\\|\\/)$/.test(destination) ? 'dir' : 'file';\n\n    const absoluteSource = path.isAbsolute(source) ? source : path.join(context, source);\n    const absoluteDestination = path.isAbsolute(destination) ? destination : path.join(context, destination);\n\n    return {\n      ...task,\n      source: normalizePath(source),\n      absoluteSource: normalizePath(absoluteSource),\n      destination: normalizePath(destination),\n      absoluteDestination: normalizePath(absoluteDestination),\n      toType,\n      context,\n    };\n  });\n}\n\nclass FileManagerPlugin implements WebpackPluginInstance {\n  private options: FileManagerPluginOptions;\n  private context!: string;\n  private logger!: Logger;\n\n  constructor(options: FileManagerPluginOptions) {\n    validate(optionsSchema, options, {\n      name: PLUGIN_NAME,\n      baseDataPath: 'actions',\n    });\n\n    this.options = { ...defaultOptions, ...options };\n  }\n\n  private async applyAction(action: unknown, actionParams: ActionTask[], compilation: Compilation): Promise<void> {\n    const opts: TaskOptions = {\n      runTasksInSeries: this.options.runTasksInSeries ?? false,\n      logger: this.logger,\n      handleError: (error) => {\n        if (!this.options.throwOnError) {\n          return;\n        }\n        compilation.errors.push(error);\n      },\n    };\n\n    if (typeof action === 'function') {\n      await action(resolvePaths(actionParams, this.context), opts);\n    }\n  }\n\n  private async run(event: Actions, compilation: Compilation): Promise<void> {\n    for (const actionType in event) {\n      const action = event[actionType];\n\n      switch (actionType) {\n        case 'delete':\n          await this.applyAction(deleteAction, action, compilation);\n          break;\n\n        case 'mkdir':\n          await this.applyAction(mkdirAction, action, compilation);\n          break;\n\n        case 'copy':\n          await this.applyAction(copyAction, action, compilation);\n          break;\n\n        case 'move':\n          await this.applyAction(moveAction, action, compilation);\n          break;\n\n        case 'archive':\n          await this.applyAction(archiveAction, action, compilation);\n          break;\n\n        default:\n          compilation.errors.push(new Error('Unknown action'));\n      }\n    }\n  }\n\n  private async execute(eventName: 'onStart' | 'onEnd', compilation: Compilation): Promise<void> {\n    const { events } = this.options;\n\n    if (!events) return;\n\n    if (Array.isArray(events[eventName])) {\n      const eventsArr = events[eventName] as Actions[];\n\n      await pExec(true, eventsArr, async (event: Actions) => await this.run(event, compilation));\n      return;\n    }\n\n    const event = events[eventName] as Actions;\n    await this.run(event, compilation);\n  }\n\n  apply(compiler: Compiler): void {\n    this.context = this.options.context || compiler.options.context || process.cwd();\n    this.logger = compiler.getInfrastructureLogger(PLUGIN_NAME);\n\n    const onStart = async (compilation: Compilation): Promise<void> => {\n      await this.execute('onStart', compilation);\n    };\n\n    const onEnd = async (compilation: Compilation): Promise<void> => {\n      await this.execute('onEnd', compilation);\n    };\n\n    compiler.hooks.beforeRun.tapPromise(PLUGIN_NAME, async (comp) => {\n      comp.hooks.thisCompilation.tap(PLUGIN_NAME, async (compilation) => {\n        await onStart(compilation);\n      });\n    });\n\n    compiler.hooks.afterEmit.tapPromise(PLUGIN_NAME, async (compilation) => {\n      await onEnd(compilation);\n    });\n\n    let watchRunCount = 0;\n    compiler.hooks.watchRun.tapPromise(PLUGIN_NAME, async (comp) => {\n      if (this.options.runOnceInWatchMode && watchRunCount > 0) {\n        return;\n      }\n\n      ++watchRunCount;\n      comp.hooks.thisCompilation.tap(PLUGIN_NAME, async (compilation) => {\n        await onStart(compilation);\n      });\n    });\n  }\n}\n\nexport default FileManagerPlugin;\n"],"mappings":";;;;;;;;;;;AAEA,MAAMA,gBAA6B;CACjC,OAAO;CACP,MAAM;CACN,sBAAsB;CACtB,aAAa;EACX,MAAM;GACJ,aAAa;GACb,MAAM;GACN,UAAU;GACV,iBAAiB;GACjB,OAAO,CACL;IACE,MAAM;IACN,sBAAsB;IACtB,YAAY;KACV,QAAQ;MACN,aAAa;MACb,MAAM;MACN,WAAW;KACZ;KACD,aAAa;MACX,aAAa;MACb,MAAM;MACN,WAAW;KACZ;KACD,SAAS;MACP,sBAAsB;MACtB,MAAM;MACN,aAAa;MACb,YAAY;OACV,MAAM;QACJ,aAAa;QACb,MAAM;QACN,SAAS;OACV;OACD,WAAW;QACT,aAAa;QACb,MAAM;QACN,SAAS;OACV;OACD,oBAAoB;QAClB,aAAa;QACb,MAAM;QACN,SAAS;OACV;MACF;KACF;KACD,aAAa;MACX,sBAAsB;MACtB,MAAM;MACN,aAAa;KACd;IACF;GACF,CACF;EACF;EACD,QAAQ;GACN,aAAa;GACb,MAAM;GACN,UAAU;GACV,iBAAiB;GACjB,OAAO,EACL,OAAO,CACL;IACE,MAAM;IACN,sBAAsB;IACtB,YAAY;KACV,QAAQ;MACN,MAAM;MACN,WAAW;KACZ;KACD,SAAS;MACP,sBAAsB;MACtB,MAAM;MACN,aAAa;KACd;IACF;GACF,GACD;IACE,MAAM;IACN,WAAW;GACZ,CACF,EACF;EACF;EACD,MAAM;GACJ,aAAa;GACb,MAAM;GACN,iBAAiB;GACjB,OAAO,CACL;IACE,MAAM;IACN,sBAAsB;IACtB,YAAY;KACV,QAAQ;MACN,aAAa;MACb,MAAM;MACN,WAAW;KACZ;KACD,aAAa;MACX,aAAa;MACb,MAAM;MACN,WAAW;KACZ;IACF;GACF,CACF;EACF;EACD,OAAO;GACL,aAAa;GACb,MAAM;GACN,UAAU;GACV,iBAAiB;GACjB,OAAO,EACL,MAAM,SACP;EACF;EACD,SAAS;GACP,aAAa;GACb,MAAM;GACN,iBAAiB;GACjB,OAAO,CACL;IACE,MAAM;IACN,sBAAsB;IACtB,YAAY;KACV,QAAQ;MACN,aAAa;MACb,MAAM;MACN,WAAW;KAC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"}